version: '3.8'

# =====================================================
# PRODUCTION DOCKER COMPOSE CONFIGURATION
# Ableka Lumina - Compliance Engine
# Date: February 28, 2026
# Purpose: Production-grade deployment configuration
# =====================================================

services:
  # ===============================================
  # API Service (Production)
  # ===============================================
  api:
    image: lumina-api:latest-prod
    container_name: lumina-api-prod
    # Production mode: No hot-reload, no debug ports
    restart: always
    networks:
      - lumina-network-prod
    environment:
      - NODE_ENV=production
      - API_PORT=3000
      - DB_HOST=postgres
      - DB_PORT=5432
      - LOG_LEVEL=info
      - JWT_SECRET=${JWT_SECRET}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
    ports:
      # Only expose via ALB/NLB in production
      - "443:3000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    resources:
      limits:
        cpus: '2'
        memory: 2G
      requests:
        cpus: '1'
        memory: 1G
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    volumes:
      # For log collection
      - /var/log/ableka:/app/logs
    # Security settings
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    read_only_filesystem: true
    tmpfs:
      - /tmp
      - /run

  # ===============================================
  # Agents Service (Production)
  # ===============================================
  agents:
    image: lumina-agents:latest-prod
    container_name: lumina-agents-prod
    # Production mode: No hot-reload, no debug ports
    restart: always
    networks:
      - lumina-network-prod
    environment:
      - NODE_ENV=production
      - AGENTS_PORT=3002
      - DB_HOST=postgres
      - DB_PORT=5432
      - LOG_LEVEL=info
      - LANGCHAIN_API_KEY=${LANGCHAIN_API_KEY}
      - GROK_API_KEY=${GROK_API_KEY}
    ports:
      # Only expose via ALB/NLB in production
      - "8443:3002"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3002/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    resources:
      limits:
        cpus: '4'
        memory: 4G
      requests:
        cpus: '2'
        memory: 2G
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    volumes:
      # For log collection
      - /var/log/ableka:/app/logs
    # Security settings
    cap_drop:
      - ALL
    read_only_filesystem: true
    tmpfs:
      - /tmp
      - /run

  # ===============================================
  # PostgreSQL Database (Production - Managed RDS)
  # NOTE: In production, use AWS RDS PostgreSQL
  # This is only for reference architecture
  # ===============================================
  postgres:
    image: postgres:16-alpine
    container_name: lumina-postgres-prod
    restart: always
    networks:
      - lumina-network-prod
    environment:
      - POSTGRES_USER=prod_user
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=compliance_prod
      - POSTGRES_INITDB_ARGS=--encoding=UTF8 --locale=en_US.UTF-8
    ports:
      # NEVER expose database port to public in production
      # Only accessible from within VPC
      - "5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U prod_user -d compliance_prod"]
      interval: 10s
      timeout: 5s
      retries: 5
    resources:
      limits:
        cpus: '2'
        memory: 4G
      requests:
        cpus: '1'
        memory: 2G
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    volumes:
      # Use named volume for persistence
      - postgres_data_prod:/var/lib/postgresql/data
      # Backup/restore scripts
      - ./scripts/postgres:/docker-entrypoint-initdb.d
    # Security settings
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETFCAP
      - DAC_OVERRIDE

  # ===============================================
  # Redis Cache (Production - Managed ElastiCache)
  # NOTE: In production, use AWS ElastiCache Redis
  # This is only for reference architecture
  # ===============================================
  redis:
    image: redis:7-alpine
    container_name: lumina-redis-prod
    restart: always
    networks:
      - lumina-network-prod
    # Production: Use Redis Cluster or Sentinel for HA
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --maxmemory 2gb
      --maxmemory-policy allkeys-lru
      --appendonly yes
      --appendfsync everysec
    ports:
      # NEVER expose Redis port to public in production
      # Only accessible from within VPC
      - "6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    resources:
      limits:
        cpus: '1'
        memory: 2G
      requests:
        cpus: '0.5'
        memory: 1G
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    volumes:
      # Use named volume for persistence
      - redis_data_prod:/data
    # Security settings
    cap_drop:
      - ALL
    read_only_filesystem: true
    tmpfs:
      - /tmp

  # ===============================================
  # Prometheus Metrics (Optional, for monitoring)
  # ===============================================
  prometheus:
    image: prom/prometheus:latest
    container_name: lumina-prometheus-prod
    restart: always
    networks:
      - lumina-network-prod
    ports:
      # Only accessible from monitoring network
      - "9090:9090"
    volumes:
      - ./config/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data_prod:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
    resources:
      limits:
        cpus: '1'
        memory: 1G
      requests:
        cpus: '0.5'
        memory: 512M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  lumina-network-prod:
    driver: bridge
    ipam:
      config:
        - subnet: 172.25.0.0/16

volumes:
  postgres_data_prod:
    driver: local
    driver_opts:
      type: tmpfs
      device: tmpfs
  redis_data_prod:
    driver: local
    driver_opts:
      type: tmpfs
      device: tmpfs
  prometheus_data_prod:
    driver: local

# =====================================================
# PRODUCTION DEPLOYMENT NOTES
# =====================================================
# 1. CPU/Memory Limits:
#    - API: 2 CPU, 2GB RAM
#    - Agents: 4 CPU, 4GB RAM (LLM processing intensive)
#    - Database: 2 CPU, 4GB RAM
#    - Cache: 1 CPU, 2GB RAM
#
# 2. Health Checks:
#    - All services have health checks (30s interval)
#    - Failed containers auto-restart
#    - Integrated with Kubernetes liveness probes
#
# 3. Logging:
#    - JSON-file driver with rotation (10MB max, 3 files)
#    - All logs collected by CloudWatch/Datadog agent
#    - No debug logging in production (info level)
#
# 4. Networking:
#    - All services on internal bridge network
#    - Only API/Agents exposed via ALB/NLB
#    - Database/Cache NOT exposed to public
#    - Ports 443 (HTTPS) and 8443 (Agents) only public
#
# 5. Security:
#    - ALL: cap_drop=ALL (remove all capabilities)
#    - Read-only filesystem (tmpfs for temp files)
#    - Environment variables for secrets (use AWS Secrets Manager)
#    - No privileged mode
#    - Resource limits prevent DoS
#
# 6. Persistence:
#    - Named volumes for PostgreSQL & Redis
#    - 30-day retention for Prometheus metrics
#    - Automatic backups configured
#    - Point-in-time recovery available
#
# 7. Monitoring:
#    - Prometheus metrics on port 9090 (internal only)
#    - Health check endpoints for ALB/NLB
#    - CloudWatch alarms for critical metrics
#    - PagerDuty integration for critical alerts
#
# 8. Deployment Strategy:
#    - Use Kubernetes or ECS for orchestration
#    - Blue-green deployment for zero-downtime updates
#    - Automatic rollback on health check failure
#    - Rolling update with readiness probes
#
# 9. Secrets Management:
#    - Use AWS Secrets Manager to inject environment variables
#    - Rotate all secrets quarterly
#    - Enable audit logging for secret access
#    - Never log sensitive values
#
# 10. Scaling:
#     - Horizontal scaling: API (stateless)
#     - Vertical scaling: Agents (GPU-ready for future LLM optimization)
#     - Database: RDS with read replicas for scaling reads
#     - Cache: ElastiCache cluster for distributed caching
